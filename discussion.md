# Discussion

- [Discussion](#discussion)
  - [Spring](#spring)
  - [Quarkus](#quarkus)
  - [Micronaut](#micronaut)
  - [Considerations](#considerations)
  
Here I will discuss _briefly_ some of the advantages and drawbacks of these frameworks. These will include mainly issues or shortcuts discovered while writing the code.  
To be clear, with `Spring` I may refer to either the entire framework ecosystem or `Spring Boot`, but in general it will be the latter.  
  
## Spring

Spring is the oldest framework of the three. It carries a lot of stability and a complete and exhaustive documentation, with lots of examples readily available on many support forums.  
At the same time it tries to keep up with the current technologies and developments, although they tend to be implemented slowly.  
Regarding the usability, it is quite simple to start, there are many good tutorials that allow to setup an app quickly and let you expand it to include the features you may need. However some parts include a steeper learning curve, for example Spring Data, that in its basic setup is simple to use, but as soon as a few relationships are established, maybe recursive, it needs to be finely tuned to simply have a working setup. Add to this that not all SQL instructions are available (e.g. `SET NULL` in cascade) and it becomes a trial and error struggle to find a combination of annotations that allow to circumvent it.  
Besides this, the available ORMs are quite inefficient in terms of SQL queries as they fetch unnecessary data (and in this case lazy fetch was not even possible).  
Moving on to the MVC pattern, it is easy and quick to implement and it does not require any pre-existing knowledge. This project is focused on an API, so I did not explore advanced features.  
Regarding the whole project, I used the usual pattern with services, repositories and controllers, which is simple to implement and effective. The documentation has everything needed to quickly setup and test the endpoints and manage exceptions. This was probably the easiest part.  
One drawback, in my opinion, of all three frameworks is that the serialization and deserialization of objects require POJOs. If we want to send or receive some slightly different objects we need to either write new objects or carefully annotate the fields of a big object that can morph in multiple variations (in the sense that according to the fields we receive we treat or cast it to different objects). A general way to write a temporary object that I can then send and forget it ever existed would have been helpful, as the manual implementation with Jackson is cumbersome (some simple wrapper functions could probably easily take care of that).  
Regarding native compilation with GraalVM, unfortunately my simple project could not be directly converted by following the procedure available at [https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/](https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/). In particular I got a `java.lang.IllegalStateException: Unexpected problem processing bytes for class [...] ConstantPoolScanner.java`. It would probably be better to either start from one of the samples available at [https://github.com/spring-projects-experimental/spring-native](https://github.com/spring-projects-experimental/spring-native) or try with an even simpler project.  

## Quarkus

Quarkus is a recent framework by Red Hat that utilizes many new and advanced libraries in order to realize the fastest framework available.  
It focuses on reactive programming, which is well integrated into the project, but that still lacks a complete support of all features. In truth, Quarkus feels like a hybrid framework where some features are available only in imperative and others in reactive, and this includes even the support to databases so, not only some specific features, but also much more important parts.  
Documentation is scarce and there are not that many examples to take notes from. Debugging sometimes results in some obscure messages related to core classes that give no real help in determining the real cause of the error.  
However, what I consider the biggest issue with Quarkus is its management of extensions: to reduce the size of the final package, available extensions are split in as many packages as possible, but this creates some confusion, when it's not really clear whether a package is a substitute for another or its a dependency and the documentation and the logs don't help in this case.  
This obviously results in smaller packages, which is a plus for the use in containerized environments (Docker, Kubernetes) but can result in a tedious job at the beginning of the setup or whenever new dependencies are needed; just by looking at the starter page ([https://code.quarkus.io](https://code.quarkus.io)), we can see a lot of extensions that are very similar but have subtle differences.  
One very useful feature of Quarkus is hot-reload, which allows to recompile only the part of the code that changed while the app is running in development mode. I personally found this very useful and it helps in reducing idle time waiting for the code to compile. If it helps with small projects I believe it would be even more useful with bigger ones.  
Continuing with the issue I had with Quarkus, I should include that support for my database of choice, H2, is lacking, in particular there is no support for [R2DBC](https://r2dbc.io/) with H2 in Quarkus and there is no direct console available, whereas for instance in Spring it's simply a matter of adding one single line in the configuration file. Besides this, I found that sometimes the framework does not detect or report problems/errors, for example if two controllers have part of the URI that overlap at the class level, only one of the two is enabled and the other one does nothing at all, with nothing reported in the logs, but simply `404` whenever we try to access one of the paths of the second controller. I had to set the whole path to each specific method inside the controllers to have both working and an empty path to the controller themselves (if the empty path is missing they don't work _again_). One last example of things that I find just strange is that `SecureRandom` objects in Quarkus can't be initialized with a seed, either at constructor level or later with a byte seed. This happens with both IO and worker threads, in the controllers, services, or even the main, in practice it simply did not work, while in Spring and Micronaut there were no problems related to this. I didn't find any comment related to this in the documentation.  
Lastly, regarding the native conversion, I can say that it is as simple as changing the maven/gradle task in the sense that the code does not need additional dependencies, but, at least for my project, required only one single annotation in the POJOs (`@RegisterForReflection`). At the same time the support is again a bit lacking, for instance H2 is not supported at all and I had to write a new project without all the CRUD API because I couldn't find any way to set in the configuration to ignore that part, without the ORM complaining of missing data sources. Now, looking back at it, I believe that it could be possible to also exclude the data dependencies in gradle whenever the native task is called, but the problem remains that I have only a partial API to test at the end.  

## Micronaut

Micronaut is the third and last framework tested, it is also relatively recent and I believe that one of its main selling points is its compatibility with as many systems, libraries etc. as possible.  
Among its extensions we can easily find integrations with frameworks such as kafka, elasticsearch; web deployments such as azure and aws etc. This is not to say that the other two are not compatible with them, but I found the setup  easier with Micronaut (at least in terms of documentation).  
Regarding the documentation, I found it quite good, not as extended as in Spring, but certainly better than Quarkus and also better organized in my opinion (e.g. whenever a feature is presented, the required dependencies and incompatibilities are also shown).  
As I said, Micronaut makes of interoperability with other frameworks a strong point, in particular I found that a Spring project can be easily ported to Micronaut just by changing a few annotations and, obviously, the gradle and application configurations. One advantage of this is that even if its popularity is lower with respect to Spring, it's still possible to look at solutions to problems written for Spring and easily port them to Micronaut with little to no changes involved, while in general this is not possible with Quarkus.  
One interesting feature of Micronaut is exploded operators, that allow to map parameters from multiple sources to a single POJO, see [https://docs.micronaut.io/snapshot/guide/#binding](https://docs.micronaut.io/snapshot/guide/#binding).  
This is to say that Micronaut is not only a framework that does the same things as Spring, but it has its own advanced features and optimizations under the hood.  
Regarding the conversion to native image, it took some time to dig through the documentation to find all changed that were necessary to achieve a working build, because some errors are shown only at runtime, and there is not a single guide that lists all the changes and limitations of a native conversion, but at the end, after adding a few annotations, changing a little bit the configuration and setting some fields to public, I managed to have a complete working application, that can be easily built from its specific gradle task, alongside the usual jar.

## Considerations

- All frameworks have some specific limitations, for example related to data and the use of ORM systems which are not that efficient as they sometimes apply by default some redundant queries that are unnecessary. On the other hand they all allow for a finer granularity of control with explicit queries.  
The lack of compatibility with some DB drivers/specifications should however be carefully considered before choosing a framework.  

- Spring appears as a framework that can do pretty much everything, but at the same time it makes things unnecessary complicated sometimes and in general requires some boilerplate code. However it is also very stable and has a good documentation with plenty of examples and use cases.  
It could probably be the go to framework for applications that require strong stability or security that only a mature framework can provide, even at the expense of a little bit of performance.  

- Quarkus has some nice features and shortcuts that could help in creating an application without boilerplate code and with advanced features. At the same time however it relies on many 3rd party libraries whose support and integration into the Quarkus framework is not optimal, in particular the development of these external libraries is done independently from Quarkus and the addition or removal of features may create problems with pre-existing applications. The team is working extensively to target these issues before they are merged, but stability is, as of now, not the best. A praise goes to their integration with containerized frameworks and in general I really enjoyed the freedom of writing an application however I wanted (reactive, imperative, async, a mix of all three). It's certainly a framework to keep a look out for and once a certain degree of stability and compatibility is reached I think it will be a very good choice to consider. It also performs the best in almost all categories of my tests.  

- Micronaut seems like in the middle between Spring and Quarkus: it is more stable than Quarkus and well documented, it includes about everything that Spring does, with smaller extensions, but not as fragmented as Quarkus. It still follows the footprints left by Spring in the way of writing code, it adds some nice features, but not that level of freedom that can be experienced in Quarkus. In particular I found that its learning curve is the best among the three.
